---
title: "Graph standards"
output: rmarkdown::html_vignette
description: What good graphs should look like
vignette: >
  %\VignetteIndexEntry{Graph standards}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r echo = FALSE, message = FALSE, warning = FALSE}
devtools::load_all()
library(ggplot2)
library(ggrepel)
library(data.table)

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.align = 'center', 
  out.width = '60%'
)

# Prep data: US personal expenditure aggregates in US$b
data <- USPersonalExpenditure
data <- as.data.table(data, keep.rownames = TRUE)
data <- melt(data, id.vars = "rn", variable.name = "year", value.name = "value")
setnames(data, "rn", "category")
data[, category := factor(category)]
data[, year := as.numeric(as.character(year))]

# 3 main categories
data_3 <- data[category %in% c("Food and Tobacco", "Household Operation", "Medical and Health")]

# Dual axis graph data
data_dual <- data[category %in% c("Food and Tobacco", "Personal Care")]
data_dual <- dcast(data_dual, year ~ category, value.var = "value")

# Column graph data
data_col <- data[year %in% c(1940, 1960) & category %in% c("Food and Tobacco", "Household Operation", "Medical and Health")]
data_col[, category := factor(category, 
                              c("Food and Tobacco", "Household Operation", "Medical and Health"),
                              c("Food", "Household", "Health"))]

# Change data
data_chg <- copy(data)[, change := value - shift(value), by = category]
```

The purpose of this vignette is to demonstrate how to use the functions in `theme61` to produce a correctly formatted graph in the e61 Institute style.

## Summary

You start by creating an unthemed graph using the 'normal' stuff: `ggplot(data, aes(x, y)) + geom_blah()`

Then:

-   [Apply the theme](#theme): `theme_e61()`
-   [Add graph colours](#colours): `scale_colour_e61()` or `scale_fill_e61()`
-   [Format the x and y axes scales](#scales): `scale_y_continuous_e61()`, `scale_x_continuous_e61()`
-   [Add labels to your lines/points/bars](#labels): `mplot_label()` or `plot_label()`
-   [Add titles, axes labels, footnotes and sources](#titles): `labs_e61(title = "Title", footnotes = "Footnotes", sources = c("Source 1", "Source 2"))`
-   [Create a multi-panel](#mpanel) (if required): `mpanel_e61()`
-   [Save the graph](#save): `save_e61()`

## The starting graph {#start}

We're going to turn a default ggplot2 graph into one that is correctly formatted in the e61 Institute style using the package features.

```{r}
gg <- ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() + theme(legend.position = "bottom")
```

```{r, echo = FALSE}
ggsave(here::here("man/figures/g-prev.svg"), gg, height = 7.9, width = 8.5, units = "cm")
knitr::include_graphics(here::here("man/figures/g-prev.svg"))
```

## Applying the e61 theme to the graph {#theme}

Most of the theming is done by the `theme_e61()` function. Simply add this to your plot and (if needed) set some arguments.

`theme_e61()` deliberately steers you away from long y-axis titles. The information required to interpret the graph should be contained in the title or subtitle.

```{r}
gg <- 
  ggplot(data, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61()
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-start.svg"), height = 6.8)
knitr::include_graphics(here::here("man/figures/g-start.svg"))
```

### The theme61 colour palette

`theme61` comes with a comprehensive colour palette that you can use in your colour and fill scales. The colour palette is built into the `theme61` colour and fill functions (`scale_colour_e61()` and `scale_fill_e61()`).

In case you want to customise the chosen colours, all of the valid colours in the e61 colour palette are stored as named objects in the package, they can be accessed by name (see [here](https://e61-institute.github.io/theme61/reference/index.html#colours) for the full list of names). The colour name can be deduced from the position in the colour palette image below.

-   Naming syntax: `e61_<colour name nospaces><numeric position on the scale>`
-   Examples: `e61_bluedark3` or `e61_maroonlight8`.
-   Specifying just the colour name (e.g. `e61_teallight`) will also select the left-most colour on the scale (colour "0").

```{r theme61-colours, echo = FALSE, out.width='80%'}
source("colour-palette.R", print.eval = TRUE)
```

## Formatting graph colours {#colours}

`scale_colour_e61()` and `scale_fill_e61()` provide access to the e61 colour palette.

Generally you just need to specify how many colours are needed as an argument.

`e61_palette()` gives you manual access to the colour hex codes.

```{r}
gg <- 
  ggplot(data, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_colour_e61(5)
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-colours.svg"), height = 6.8)
knitr::include_graphics(here::here("man/figures/g-colours.svg"))
```

## Formatting axis scales {#scales}

`scale_y_continuous_e61()` is the preferred axis scale function for graphs. It duplicates the axis by default and allows you to specify the axis limits in the `limits` argument to ensure good aesthetics. You should manually specify the limits rather than relying on the defaults as they are likely to be a bit unaesthetic.

### Axes labelling

As Greg's prime graph directive states, the title and subtitle of your graph should reflect what the data shows, not what you interpret the graph to be showing.

Thus, there should be enough information in the title that your y-axis label does not need to repeat what the data are. Consequentially, the y-axis labels in `theme61` are designed to have space for short labels of 1-5 characters.

The package also defaults to showing no x-axis. This is because the x-axis is usually very obvious. For example, if the x-axis is "2010, 2011, 2012, ...", then it is obviously a time series in years, which would be a waste of space to label. Save the x-axis labels for when the x-axis actually requires explanation.

Some examples of y-axis labels:

-   **Good:** %, ppt, \$, '000, \$m, \$b, index, ratio.
-   **Bad (these are all too long):** US Personal Expenditures (\$ billions), Number of individuals, Model coefficient estimates (ppt), Other long sentences.

```{r}
gg <- 
  ggplot(data, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(5)
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-axis.svg"), height = 6.8)
knitr::include_graphics(here::here("man/figures/g-axis.svg"))
```

## Plot labelling {#labels}

*A full guide to plot labelling is [here](ongraph-labels.html).*

Graph legends are inferior to labels on the graph, so `theme61` defaults to hiding the legends.

This is because legends require you to rapidly flip between the coloured lines or bars on the graph and match them with a box outside the graph that tells you what that colour represents. This creates additional cognitive load, making the message of your graph harder and slower to communicate to the audience and therefore your graph is less effective.

Graph labels put the label on the graph directly, near the data point that is being identified. This makes it faster to figure out what the graph is about.

```{r}
gg <- 
  ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(3) +
  mplot_label(c("Food and\nTobacco", "Household\nOperation", "Medical and\nHealth"),
              c(1944, 1954, 1953),
              c(65, 55, 25))
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-labels.svg"), height = 6.8)
knitr::include_graphics(here::here("man/figures/g-labels.svg"))
```

## Graph titles, subtitles and footers {#titles}

When adding titles, subtitles, captions and sources, use `labs_e61()`. Text is automatically wrapped if it is too long on one line. You can adjust this or turn it off. Sources are automatically reordered in alphabetical order if you supply the sources as a character vector.

```{r}
gg <- 
  ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(3) +
  mplot_label(c("Food and\nTobacco", "Household\nOperation", "Medical and\nHealth"),
              c(1944, 1954, 1953),
              c(65, 55, 25)) +
  labs_e61(
    title = "US Personal Expenditures*",
    subtitle = "1940-1960",
    footnotes = "Data comes from the built-in 'USPersonalExpenditure' dataset.",
    sources = c("e61 Institute", "'datasets' package")
  )
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-titles.svg"), height = 8.3)
knitr::include_graphics(here::here("man/figures/g-titles.svg"))
```

## Saving graphs {#save}

Use `save_e61()` when saving graphs at e61. `save_e61()` ensures that the relative size of your graph elements and text is appropriate by setting sensible defaults on the graph dimensions.

You should save your graphs using a vector graphics format (SVG or PDF). SVGs are a modern vector graphics format, which is the highly recommended format because you can resize them to any size without pixelation. If you are making graphs for LaTeX documents, you will need to save the graphs in PDF format for them to render as LaTeX does not support SVGs. If for some reason you need to use a raster format, the package provides limited support for PNGs, although some customisation features may be unavailable.

You do not need to supply the ggplot object when using `save_e61()` as it automatically saves the last-created graph. *However*, if you are saving a multi-panel graph and want the automatic width and height adjustment to work, you *do* need to supply the graph object as an argument, i.e. do this: `save_e61("filename.svg", graph_object)` rather than `save_e61("filename.svg")`.

The `save_data` argument also lets you save a `.csv` file with the data used to create a graph.

### Proper height selection when saving graphs

Here I have made a graph with a pink background to show you the issues with height selection when saving graphs.

```{r}
gg <- 
  ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(3) +
  mplot_label(c("Food and\nTobacco", "Household\nOperation", "Medical and\nHealth"),
              c(1944, 1954, 1953),
              c(65, 55, 25)) +
  labs_e61(
    title = "US Personal Expenditures*",
    subtitle = "1940-1960",
    footnotes = "Data comes from the built-in USPersonalExpenditure dataset.",
    sources = c("e61 Institute", "'datasets' package")
  ) +
  theme(plot.background = element_rect(fill = "lightpink"))

```

This graph is not 'tall' enough, `height` is too small. You can see the contents of the graph is squashed together and the footnote text spills past the graph border.

```{r}
save_e61(here::here("man/figures/g-save-wide.svg"), height = 6)
knitr::include_graphics(here::here("man/figures/g-save-wide.svg"))
```

This graph is too 'tall', `height` is too large as you can see a lot of whitespace above and below the graph border.

```{r}
save_e61(here::here("man/figures/g-save-tall.svg"), height = 11)
knitr::include_graphics(here::here("man/figures/g-save-tall.svg"))
```

This graph is just right, `height` is set correctly as there is no excess space around the graph.

```{r}
save_e61(here::here("man/figures/g-save-good.svg"), height = 8.5)
knitr::include_graphics(here::here("man/figures/g-save-good.svg"))
```

### Automatic height setting feature (experimental)

`save_e61()` has an experimental auto-height calculation feature. It has the goal of automatically getting the height 'just right' like in the previous slide. It works fairly well if your graph axes are in the 'normal' range (units are not too big or small, axis label is 1-3 characters). It kind of works with multi-panel graphs if you specify the graph object explicitly in the `save_e61()` function.

The calculation gets fairly close but you may need to add a subtract a few fractions of a centimetre to get it just right. Conveniently the function will print the height setting it has chosen in the console so you can use that as a starting base. On publication-quality graphs it is probably a good idea to adjust the height from the automatic value.

## Additional features

### Dual y-axis scale support

Note: Admittedly this feature is somewhat advanced/fiddly.

Despite [Hadley's best efforts](https://stackoverflow.com/questions/3099219/ggplot-with-2-y-axes-on-each-side-and-different-scales/3101876#3101876) to make it difficult to add a differently-scaled second y-axis, this feature now exists in `theme61.`

Implementing dual y-axis requires a fair amount of additional faff that I will try and step through.

First, the structure of your data needs to be different to the usual best practice. Normally, you want your data in long format, and add separate groups using `colour` or `fill`. However, if you want one of the lines on the secondary axis, each series needs to be in its own column. 

Each series will also be plotted separately with its own `geom_line()` (or any other `geom_` depending on what you want to plot obviously), as in the example below.

You need to then transform the `y` aesthetic in the series to be plotted on the secondary axis using the `sec_rescale_inv()` function (see the documentation for the required arguments).

You also need to manually specify the colour to colour in the lines, using `e61_palette()`.

You must then specify the `sec_axis` argument in `scale_y_continuous_e61()` with `sec_axis(~sec_rescale(.), name = "name")`. Replace "name" with the y-axis label. This must be specified otherwise it will show up blank.

You also need to set `rescale_sec = TRUE` to ensure the formatting is appropriately adjusted for the secondary axis.

Finally, you will need to run your code twice, as the first time, there will be an error caused by how R internally assigns objects generated by simultaneous function calls (this may get fixed in the future). 

```{r, echo = FALSE}
# Store scale and shift vars to supply to sec_rescale()
# This is needed for the vignette to run
assign("sec_axis_scale", 0.1, envir = t61_env)
assign("sec_axis_shift", 0, envir = t61_env)
```

```{r}
gg <- 
  ggplot(data_dual, aes(x = year)) + 
  geom_line(aes(y = `Food and Tobacco`), colour = e61_palette(2)[[1]]) +
  # All the action is in the next two lines
  geom_line(aes(y = sec_rescale_inv(`Personal Care`, scale = 0.1, shift = 0)), 
            colour = e61_palette(2)[[2]]) +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b",
                         sec_axis = sec_axis(~sec_rescale(.), name = "$b"), 
                         rescale_sec = TRUE) +
  theme_e61() +
  mplot_label(c("Food and Tobacco\n(LHS)", "Personal Care\n(RHS)"),
              c(1945, 1948),
              c(75, 40))
```

```{r, echo=FALSE}
save_e61(here::here("man/figures/g-dual.svg"), height = 6.8)
knitr::include_graphics(here::here("man/figures/g-dual.svg"))
```

### Multi-panel graph support {#mpanel}

We have discovered in our research notes that putting multiple graphs together in a grid/panel works quite well with the format. `mpanel_e61()` is a function that makes the task of producing multi-panel graphs easier.

Note that graph titles need to be done differently in multi-panels. Each individual graph probably should not have sources or footnotes, they should be in the footer of the full multi-panel instead.

First we make the sub-plots as their own graph.

```{r}
g1 <- 
  ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(3) +
  mplot_label(c("Food and\nTobacco", "Household\nOperation", "Medical and\nHealth"),
              c(1944, 1954, 1953),
              c(65, 55, 25)) +
  labs_e61(
    title = "Aggregates"
  )

g2 <- 
  ggplot(data_dual, aes(x = year)) + 
  geom_line(aes(y = `Food and Tobacco`), colour = e61_palette(2)[[1]]) +
  geom_line(aes(y = sec_rescale_inv(`Personal Care`, scale = 0.1)), 
            colour = e61_palette(2)[[2]]) +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b",
                         sec_axis = sec_axis(~sec_rescale(.), name = "$b"), 
                         rescale_sec = TRUE) +
  mplot_label(c("Food and Tobacco\n(LHS)", "Personal Care\n(RHS)"),
              c(1945, 1948),
              c(75, 40)) +
  labs_e61(
    title = "Selected Aggregates"
  )

g3 <-
  ggplot(data_col, aes(x = category, y = value, fill = factor(year))) +
  geom_col(position = "dodge") +
  theme_e61() +
  scale_fill_e61(2) +
  scale_y_continuous_e61(limits = c(0, 90, 30)) +
  mplot_label(c("1940", "1960"),
              c(1.55, 2.05),
              c(15, 50)) +
  labs_e61(
    title = "1940 to 1960 Change", y = "$b"
  )

g4 <- 
  ggplot(data_chg[category == "Food and Tobacco"], aes(x = year)) +
  geom_line(aes(y = value), colour = e61_palette(2)[[1]]) +
  geom_col(aes(y = change), fill = e61_palette(2)[[2]]) +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 90, 30)) +
    mplot_label(c("Aggregate", "Change from\n5 years ago"),
              c(1941, 1952),
              c(55, 25)) +
  labs_e61(
    title = "Food and Tobacco Spending", y = "$b"
  )
```

Then we use the `mpanel_e61()` function to put the graphs together.

```{r}
gg <-
  mpanel_e61(
    g1, g2, g3, g4,
    title = "US Personal Expenditures*",
    footnotes = "Data comes from the built-in USPersonalExpenditure dataset.",
    sources = c("e61 Institute", "'datasets' package"
    )
)

save_e61(here::here("man/figures/g-multi.svg"), gg)
```

```{r, echo=FALSE}
knitr::include_graphics(here::here("man/figures/g-multi.svg"))
```

### Flipped bar graphs

Flipped bar graphs can be useful, especially if the categories have long names. There are some changes to the `theme()` and `coords` that are required for the flipping to look successful, so I've added a function that does most of the tinkering for you. I called it `format_flipped_bar()`.

```{r}
gg <-
  ggplot(data_col, aes(x = category, y = value, fill = factor(year))) +
  geom_col(position = "dodge") +
  coord_flip() +
  theme_e61() +
  scale_fill_e61(2) +
  scale_y_continuous_e61(limits = c(0, 90, 30)) +
  mplot_label(c("1940", "1960"),
              c(1.8, 2.2),
              c(15, 50)) +
  labs_e61(
    title = "1940 to 1960 Change", y = "$b"
  ) +
  format_flipped_bar()

save_e61(here::here("man/figures/g-flip.svg"))

```

```{r, echo=FALSE, out.width='80%'}
knitr::include_graphics(here::here("man/figures/g-flip.svg"))
```

Notice that `save_e61()` set the default dimensions for flipped graphs reasonably well. Your mileage may vary if you have a weird graph though, so always check the output!

## The finished product

```{r, include=FALSE}
gg <- 
  ggplot(data_3, aes(x = year, y = value, colour = category)) + 
  geom_line() +
  theme_e61() +
  scale_y_continuous_e61(limits = c(0, 100, 25), name = "$b") +
  scale_colour_e61(3) +
  mplot_label(c("Food and\nTobacco", "Household\nOperation", "Medical and\nHealth"),
              c(1944, 1954, 1953),
              c(65, 55, 25)) +
  labs_e61(
    title = "US Personal Expenditures*",
    subtitle = "1940-1960",
    footnotes = "Data comes from the built-in USPersonalExpenditure dataset.",
    sources = c("e61 Institute", "'datasets' package")
  )
save_e61(here::here("man/figures/g-post.svg"))
```

```{r, echo=FALSE, out.width="49%", out.height="20%", fig.cap=" ", fig.show='hold', fig.align='center'}
knitr::include_graphics(c(here::here("man/figures/g-prev.svg"), here::here("man/figures/g-post.svg")))
```
